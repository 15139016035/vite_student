# vite环境变量配置

环境变量：根据当前代码的环境产生值变化的变量就是环境变量；

○ 根据启动命令 来决定是什么环境决定是否加载 其他的.env文件
○ 默认加载到的.env文件，默认解析VITE_开头的键值对
○ vite中会把环境变量放置到我们的Import.meta.env对象中
○ 涉及到三个配置：
    ■ 第一个：mode(一般都是由我们的启动命令决定)
    ■ 第二个：.env文件的所在目录，
    ■ 第三个：prefixes是匹配以什么开头的键值对；
● vite可以使用loadEnv(mode,envDir,prefixes)：可以配置这三个参数
● 也能够在vite.config.js中配置这三个参数；


● 来讲一下vite加载环境变量的过程：基于loadEnv或者vite.config.js配置的方式
    ○ 首先有三个文件 ：
        ■ .env(所有环境通用的环境变量配置)
        ■ .env.development (开发环境用到的环境变量配置)
        ■ .env.production(生产环境用到的环境变量配置)
        ■ .env.test (测试环境用到的环境变量配置)
    ○ 其次 没有配置 envDir 和 prefixes 都是用默认值
    ○ 第一步:我们使用命令yarn dev 启动项目， 实际上执行的是 yarn dev --mode development这个命令；
    ○ 第二步：mode的值就等于development ，
    ○ 第三步：立即加载工作目录下的.env文件 ，这个通用的环境配置是必须加载，解析VITE_开头的键值对保存到A对象中；
    ○ 第四步：根据mode的值进行拼接 最终拼接的结果就是 .env.development ;解析VITE_开头的键值对保存到B对象中；
    ○ 第五步：因为是dev环境，必须保证环境变量的值绝对是匹配dev环境的；会将B对象去覆盖且合并A对象，生成C对象；伪代码：C ={...A,...B};
    ○ 第六步：将C对象中的环境变量值，赋予给 import.meta.env对象中；
    ○ 完成；

● 此时我们就有了三种方式来加载环境变量；此时我们就要提到时机的问题了：


● 代码一：使用loadEnv()函数，配置三个参数，看打印，env对象的值
● 如果我们在代码一loadEnv()存在的基础上，进行配置文件的修改：
    ○ 在配置文件中：配置envDir 和 prefixes，mode根据启动命令而来，不需要额外配置；
    ○ 那么此时loadEnv()中的配置就失效了， 配置文件中的配置会覆盖loadEnv()的配置；




● 代码一
    ○ 使用 yarn dev 启动项目 其实就是 mode就等于development，
    ○ process.cwd() 是获取当前工作目录，就等于工作目录的根目录
    ○ 未在其它任何地方对env的三个参数进行其他配置，现在env打印拿到了想要的结果
```javaScript
export default defineConfig(({command,mode})=>{


    //第一步嗲用loadEnv()
    const env = loadEnv(mode,process.cwd(),"VITE_");
        console.log("我想要打印:",env)

//最会返回，配置文件，让配置文件生效；
return envResolver[command]();



});
```




我们本章节做了什么？（做了什么也就是学了什么）
1. 新建了.env .env.development .env.production .env.test 四个文件想要去区分环境变量；
2. 新建了 vite.base.config.js ,vite.dev.config.js ,vite.prod.config.js, vite.config.js ,四个配置文件
   3. vite.base.config.js 放的是公用的配置，  vite.dev.config.js是dev环境才会用到的配置 ，vite.prod.config.js是生产才会用到的配置；
   4. vite.config.js是主配置文件 ，这里面不进行任何配置，只是通过我们启动的命令 决定我们用哪个配置；
5. 然后我们通过loadEnv，来根据启动的命令，的mode来决定加载哪个配置文件
6. 然后我们在配置中设置了 envPrefix: "ENV_" 来覆盖原来的默认 .env的匹配前缀，只匹配.env文件中的ENV_前缀的我呢见

