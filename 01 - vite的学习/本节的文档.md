本章节中： vite开箱即用的初体验； 学习什么是vite的依赖预构建
1.第一引出yarn：
      index.html中引入main.js ，main.js引入counter.js ； 我们yarn init 初始化这个项目，并且下载lodash的依赖； 并且在counter.js中 import _ from 'lodash'; 希望引入lodash；但是浏览器报错了；
      因为es6的模块化 要求你必须使用相对路径或者绝对路径去引入依赖；
1.1 提出第一个疑问：为什么，es6不帮我们多做异步操作，比如我找不到就去工作目录的node_nodules下找一下，再找不到再报错；
       首先我们可以发现：我们的index.html 和main.js和counter.js 都是通过http请求加载的；
       假设做了这个事情：因为会可能lodash可能还会引用其他很多的依赖 ，看浏览器，会把相关的依赖都通过http网络资源加载进来，会非常消耗网络资源性能的；
       而commonjs可以，是因为它是专为服务端的模块化，依赖都在本地，不需要请求网络资源，直接读本地的文件；

2.我们直接安装vite
    我们的vite 只是用来做代码处理的，所以安装vite的时候 -D ，开发时候使用；
    yarn add vite -D
3.vite 安装后 再package.json中添加  "scripts": {"dev": "vite"}
    走 vite的命令启动项目
    项目启动后，没有报错；lodash成功被加载；
    vite会看到非绝对路径或者相对路径的引用，会尝试开启路径补全；
    将 import _ from 'lodash'; ---》 import __vite__cjsImport0_lodash from "/node_modules/.vite/deps/lodash.js?v=6849315d";

4.如果第三方包是commonjs的模块化，使用module.exports导出的怎么办呢？
    这就涉及到vite的依赖预构建，vite会先找到对应的依赖，然后调用esbuild(对js语法处理的一个库)，会将其他的模块化转化为esmodule的规范，
    然后放到工作目录下的node_modules/.vite/.deps/ 目录下；
5.依赖预构建解决的问题：
    1.不同的模块化的第三方包都会转化为esmodule的模块化；
    2.因为依赖预构建后的新的js文件都放到同一个位置/node_modules/.vite/deps/ ，一次性对路径进行了处理，方便路径的重写
    3.网络多包传输的性能问题，假设lodash依赖了其他的模块，/node_modules/.vite/deps/ 下重写后的js会把依赖的代码都集成到这一个文件；
      就不用通过http去加载它依赖的模块了；
6.关于依赖预构建的第一个vite.config.js配置 ； optimization: { exclude: ["lodash"]} ，去这个文件搜索exclude